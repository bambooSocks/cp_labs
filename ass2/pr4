#define P(X) atomic{ X > 0 -> X-- }
#define V(X) atomic{ X++ }
#define DOWNWARD(X) ( X <= 2 )
#define UPWARD(X) ( X >= 3 )

pid downward1, downward2, upward1, upward2;
byte downwardsMutex, alleyMutex, counterMutex, isFirstMutex, counter;
bool isDirDownward, isFirst, isFirstDownwards;

proctype Car(byte no) {
	do :: 	
		/*ENTER*/
		bool isOppositeDir = (DOWNWARD(no) != isDirDownward);
		if :: isOppositeDir -> 
			P(isFirstMutex);
			isFirstDownwards = (isFirst && DOWNWARD(no));
			V(isFirstMutex);
			if 
			:: isFirstDownwards ->
                P(isFirstMutex);
				isFirst = 0;
                V(isFirstMutex);

				P(downwardsMutex);
				P(alleyMutex);
				V(downwardsMutex)
			:: !isFirstDownwards && DOWNWARD(no) ->
				P(downwardsMutex);
				V(downwardsMutex)
			:: UPWARD(no) -> P(alleyMutex)
			fi;
			isDirDownward = DOWNWARD(no)
            :: !isOppositeDir -> skip
		fi;
		P(counterMutex);
		counter = counter + 1;
		V(counterMutex);
		/*LEAVE*/
		P(counterMutex);
		counter = counter - 1;
		if :: counter == 0 ->
			V(alleyMutex);
			if :: DOWNWARD(no) ->
				P(isFirstMutex);
				isFirst = 1;
				V(isFirstMutex)
                :: UPWARD(no) -> skip
			fi
            :: counter != 0 -> skip
		fi
		V(counterMutex)
	od
}


init {
	atomic {
		isFirst = 1;
		isDirDownward = 0;
		downwardsMutex = 1;
		alleyMutex = 1;
		counterMutex = 1;
		isFirstMutex =1;
		counter = 0
	}
	atomic {
		downward1 = run Car(1);
		downward2 = run Car(2);
		upward1 = run Car(3);
		upward2 = run Car(4)
	}
} 